
(* Context:  KnoxPackages`LinearAlgebra` *) 

(* Mathematica Version:  11.1 *)

(*:Author: Dennis M. Schneider with assistance from Robby S. Villegas *)

(* Copyright 1990-18 by Dennis M. Schneider *)

(* Work on this package partially supported by grants from
		Pew Charitable Trusts
		National Science Foundation
			NSF-ILI Grant # USE-9050757
			NSF Grant # USE-9153249
	 	Lilly Foundation
	 	Knox College
*) 


Unprotect[SetAttributes, Set, Attributes];
Clear[SetAttributes, Set, Attributes];
Protect[SetAttributes, Set, Attributes];

(*
Abort::nolic = "KnoxPackages are not licensed to this machine.";
If[Not[MatchQ["5119-78768-59794", $MachineID]], Message[Abort::nolic]; Quit[]];
*)

BeginPackage["KnoxPackages`LinearAlgebra`",{"KnoxPackages`CommonFunctions`"}];


NewGeometricTransformation::usage = 
"NewGeometricTransformation returns the Graphics or Graphics3D object generated by Mathematica's GeometricTransformation applied to the graphics part of the object and passing the options of the object. ";

AppendColumn::usage = 
"AppendColumn\!\(\(\*StyleBox[\"[\",\"TR\"]\)\(\(\*StyleBox[\"mat\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\)\(\*StyleBox[\"]\",\"TR\"]\)\) appends the vector \!\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\) as the last column of the matrix \!\(\*StyleBox[\"mat\",\"TI\"]\).  
AppendColumn\!\(\(\*StyleBox[\"[\",\"TR\"]\)\(\(\*StyleBox[\"mat\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"\[Ellipsis]\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)\)\(\*StyleBox[\"]\",\"TR\"]\)\) appends the vectors \!\(\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"\[Ellipsis]\",\"TI\"]\)\) as the last columns of the matrix \!\(\*StyleBox[\"mat\",\"TI\"]\). 
AppendColumn\!\(\(\*StyleBox[\"[\",\"TR\"]\)\(\(\*StyleBox[\"mat\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"b\",\"TI\"]\)\)\(\*StyleBox[\"]\",\"TR\"]\)\) appends the vector \!\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\*StyleBox[\"b\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"b\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"\[Ellipsis]\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\) as the last column of the matrix. ";

AppendRow::usage = 
"AppendRow\!\(\(\*StyleBox[\"[\",\"TR\"]\)\(\(\*StyleBox[\"mat\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\)\(\*StyleBox[\"]\",\"TR\"]\)\) appends the vector \!\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\) as the last row of the matrix \!\(\*StyleBox[\"mat\",\"TI\"]\).
AppendRow\!\(\(\*StyleBox[\"[\",\"TR\"]\)\(\(\*StyleBox[\"mat\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"\[Ellipsis]\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)\)\(\*StyleBox[\"]\",\"TR\"]\)\) appends the vectors \!\(\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"\[Ellipsis]\",\"TI\"]\)\) as the last rows of the matrix \!\(\*StyleBox[\"mat\",\"TI\"]\). 
AppendRow\!\(\(\*StyleBox[\"[\",\"TR\"]\)\(\(\*StyleBox[\"mat\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"b\",\"TI\"]\)\)\(\*StyleBox[\"]\",\"TR\"]\)\) appends the vector \!\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\*StyleBox[\"b\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"b\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"\[Ellipsis]\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\) as the last row of the matrix. ";

AugmentedMatrix::usage = 
"AugmentedMatrix\!\(\(\*StyleBox[\"[\",\"TR\"]\)\(\(\*StyleBox[\"eqns\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"vars\",\"TI\"]\)\)\(\*StyleBox[\"]\",\"TR\"]\)\) returns the augmented matrix of the system of equations \!\(\*StyleBox[\"eqns\",\"TI\"]\) in the variables \!\(\*StyleBox[\"vars\",\"TI\"]\). Matrix equations or a list of matrix equations are allowed. If \!\(\*StyleBox[\"eqns\",\"TI\"]\) is a list of expressions, then it is assumed that the right-hand sides are 0. ";

BasisIntersection::usage = 
"BasisIntersection\!\(\(\*StyleBox[\"[\",\"TR\"]\)\(\(\*StyleBox[\"list1\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"list2\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"\[Ellipsis]\",\"TI\"]\)\)\(\*StyleBox[\"]\",\"TR\"]\)\) returns a basis for the intersection of the subspaces of \!\(\(\*StyleBox[\"\[DoubleStruckCapitalR]\",\"TR\"]\)\^\(\*StyleBox[\"n\",\"TI\"]\)\) spanned by \!\(\(\*StyleBox[\"list1\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"list2\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"\[Ellipsis]\",\"TI\"]\)\). ";

BasisSum::usage = 
"BasisSum\!\(\(\*StyleBox[\"[\",\"TR\"]\)\(\(\*StyleBox[\"list1\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"list2\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"\[Ellipsis]\",\"TI\"]\)\)\(\*StyleBox[\"]\",\"TR\"]\)\) returns a basis for the sum of the subspaces of \!\(\(\*StyleBox[\"\[DoubleStruckCapitalR]\",\"TR\"]\)\^\(\*StyleBox[\"n\",\"TI\"]\)\) spanned by \!\(\(\*StyleBox[\"list1\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"list2\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"\[Ellipsis]\",\"TI\"]\)\). ";

ChangeBasis::usage = 
"ChangeBasis\!\(\(\*StyleBox[\"[\",\"TR\"]\)\(\(\*StyleBox[\"mat\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"\[ScriptCapitalB]\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"\[ScriptCapitalB]\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\)\(\*StyleBox[\"]\",\"TR\"]\)\) assumes that \!\(\*StyleBox[\"mat\",\"TI\"]\) is the matrix of a transformation with respect to the standard bases on \!\(\(\*StyleBox[\"\[DoubleStruckCapitalR]\",\"TR\"]\)\^\(\*StyleBox[\"n\",\"TI\"]\)\) and \!\(\(\*StyleBox[\"\[DoubleStruckCapitalR]\",\"TR\"]\)\^\(\*StyleBox[\"m\",\"TI\"]\)\) and returns the matrix with respect to the bases \!\(\(\*StyleBox[\"\[ScriptCapitalB]\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\) on \!\(\(\*StyleBox[\"\[DoubleStruckCapitalR]\",\"TR\"]\)\^\(\*StyleBox[\"n\",\"TI\"]\)\) and the basis \!\(\(\*StyleBox[\"\[ScriptCapitalB]\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\) on \!\(\(\*StyleBox[\"\[DoubleStruckCapitalR]\",\"TR\"]\)\^\(\*StyleBox[\"m\",\"TI\"]\)\).  
ChangeBasis\!\(\(\*StyleBox[\"[\",\"TR\"]\)\(\(\*StyleBox[\"mat\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"\[ScriptCapitalB]\",\"TI\"]\)\)\(\*StyleBox[\"]\",\"TR\"]\)\) returns ChangeBasis\!\(\(\*StyleBox[\"[\",\"TR\"]\)\(\(\*StyleBox[\"mat\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"\[ScriptCapitalB]\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"\[ScriptCapitalB]\",\"TI\"]\)\)\(\*StyleBox[\"]\",\"TR\"]\)\). ";

CoefficientMatrix::usage = 
"CoefficientMatrix\!\(\(\*StyleBox[\"[\",\"TR\"]\)\(\(\*StyleBox[\"eqns\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"vars\",\"TI\"]\)\)\(\*StyleBox[\"]\",\"TR\"]\)\) returns the coefficient matrix of the system of equations \!\(\*StyleBox[\"eqns\",\"TI\"]\) in the variables \!\(\*StyleBox[\"vars\",\"TI\"]\). The equations \!\(\*StyleBox[\"eqns\",\"TI\"]\) may be a list of equations, a matrix equation, or a list of matrix equations. ";

ColumnSpace::usage = 
"ColumnSpace\!\(\(\*StyleBox[\"[\",\"TR\"]\)\(\*StyleBox[\"mat\",\"TI\"]\)\(\*StyleBox[\"]\",\"TR\"]\)\) returns a basis for the subspace spanned by the columns of the matrix \!\(\*StyleBox[\"mat\",\"TI\"]\). ";

ConstraintEqns::usage = 
"ConstraintEqns[\!\(\(\*StyleBox[\"mat\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\)] returns the constraint equations that vector \!\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\) must satisfy to belong to the column space of matrix \!\(\*StyleBox[\"mat\",\"TI\"]\).
ConstraintEqns[\!\(\(\*StyleBox[\"mat\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"b\",\"TI\"]\)\)] returns the constraint equations that the vector \!\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\*StyleBox[\"b\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"b\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\) must satisfy. ";

Coordinates::usage=
"Coordinates\!\(\(\*StyleBox[\"[\",\"TR\"]\)\(\(\*StyleBox[\"vecs\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"\[ScriptCapitalB]\",\"TI\"]\)\)\(\*StyleBox[\"]\",\"TR\"]\)\) returns the coordinates of the vectors \!\(\*StyleBox[\"vecs\",\"TI\"]\) with respect to the basis \!\(\*StyleBox[\"\[ScriptCapitalB]\",\"TI\"]\).  
Coordinates\!\(\(\*StyleBox[\"[\",\"TR\"]\)\(\(\*StyleBox[\"vecs\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"\[ScriptCapitalB]\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"x\",\"TI\"]\)\)\(\*StyleBox[\"]\",\"TR\"]\)\) returns the coordinates of the vectors \!\(\*StyleBox[\"vecs\",\"TI\"]\) with respect to the basis \!\(\*StyleBox[\"\[ScriptCapitalB]\",\"TI\"]\) when the vectors and basis are members of a function space consisting of functions of \!\(\*StyleBox[\"x\",\"TI\"]\). ";



NewLU::usage = 
"NewLU[mat] returns the lower triangular matrix L and the upper triangular matrix U as well as the permutation matrix P used for pivoting to obtain the LU factorization.";

LDU::usage = 
"LDU[mat] returns the the lower triangular matrix L, the diagonal matrix D, and the upper triangular matrix U as well as the permutaion matrix P used for pivoting to obtain the LDU factorization of mat.";

matE::usage = 
"Obsolete. matE[i,j,m,n] returned the m x n matrix whose only nonzero entry was a 1 in the position i,j. It has been replaced by UnitMatrix[m,n,i,j]. Note the change in the order of the arguments.";

UnitMatrix::usage = 
"UnitMatrix[m,n,i,j] returns the m x n matrix whose only nonzero entry is a 1 in position i,j.  UnitMatrix[n,i,j] returns UnitMatrix[n,n,i,j].";

LeftNullSpace::usage = 
"LeftNullSpace[\!\(\*StyleBox[\"mat\",\"TI\"]\)] returns a basis for the left nullspace of the matrix \!\(\*StyleBox[\"mat\",\"TI\"]\).";

StandardBasisMatrices::usage = 
"StandardBasisMatrices[\!\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\*StyleBox[\"m\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)] returns the standard basis for the space of \!\(\(\*StyleBox[\"m\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) matrices.
StandardBasisMatrices[\!\(\*StyleBox[\"n\",\"TI\"]\)] returns StandardBasisMatrices[\!\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)]. ";

SBMatrices::usage = 
"SBMatrices[\!\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\*StyleBox[\"m\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)] returns the standard basis for the space of \!\(\(\*StyleBox[\"m\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) matrices.
SBMatrices[\!\(\*StyleBox[\"n\",\"TI\"]\)] returns StandardBasisMatrices[\!\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)]. ";

StandardBasisSMatrices::usage = 
"StandardBasisSMatrices[\!\(\*StyleBox[\"n\",\"TI\"]\)] returns the standard basis for the space of \!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) symmetric matrices. ";

SBSMatrices::usage = 
"SBSMatrices[size] returns StandardBasisSMatrices[size].";

StandardBasisSSMatrices::usage = 
"StandardBasisSSMatrices[\!\(\*StyleBox[\"n\",\"TI\"]\)] returns the standard basis for the space of \!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) skew-symmetric matrices. ";

SBSSMatrices::usage = 
"SBSSMatrices[size] returns StandardBasisSSMatrices[size].";

StandardBasisTraceZeroMatrices::usage = 
"StandardBasisTraceZeroMatrices[\!\(\*StyleBox[\"n\",\"TI\"]\)] returns the standard basis for the space of \!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) matrices with trace zero. ";

SBTZMatrices::usage = 
"SBTZMatrices[size] returns StandardBasisTraceZeroMatrices[size].";

StandardBasisDiagonalMatrices::usage = 
"StandardBasisDiagonalMatrices[n] returns the standard basis for the space of n x n diagonal matrices.";

SBDMatrices::usage = 
"SBDMatrices[size] returns StandardBasisDiagonalMatrices[size].";

StandardBasisPolys::usage = 
"StandardBasisPolys[\!\(\(\*StyleBox[\"var\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\)] returns the standard basis for the polynomials of degree \!\(\(\*StyleBox[\"<=\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) in the variable \!\(\*StyleBox[\"var\",\"TI\"]\). ";

SBPolys::usage = 
"SBPolys[var, n] returns StandardBasisPolys[var, n].";

StandardBasisTrigPolys::usage = 
"StandardBasisTrigPolys[\!\(\(\*StyleBox[\"var\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\)] returns the standard basis for the trigonometric polynomials of degree \!\(\(\*StyleBox[\"<=\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) in the variable \!\(\*StyleBox[\"var\",\"TI\"]\). ";

SBTPolys::usage = 
"SBTPolys[var, n] returns StandardBasisTrigPolys[var, n].";

FindMatrix::usage = 
"FindMatrix[trans, vBasis, wBasis, vars] returns the matrix of the transformation defined in terms of vars with respect to the bases vBasis and wBasis assuming trans is from R^n to R^m.  FindMatrix[trans, vBasis, vars] returns FindMatrix[trans, vBasis, vBasis, vars].  FindMatrix[vValues, wBasis] returns the matrix of a transformation from R^n to R^m with respect to the vBasis and wBasis assuming that vValues are its values on the vBasis.  FindMatrix[purefunction, vBasis, wBasis, var] returns the matrix of the transformation defined by a pure function assuming one or both bases involve the variable var.";

FindStandardMatrix::usage = 
"FindStandardMatrix[vValues, vBasis] returns the standard matrix of a transformation assuming that vValues are its values on the vBasis.";



TridiagonalMatrix::usage = 
"TridiagonalMatrix[{list1, list2, list3}] returns the square matrix whose first subdiagonal is consists of the elements in list1, whose main diagonal consists of the elements in list2, and whose superdiagonal consists of the elements in list3.
TridiagonalMatrix[{a,b,c},{m,n}] returns an mxn matrix whose first subdiagonal consists of a, whose main diagonal consists of b, and whose superdiagonal consists of c. 
TridiagonalMatrix[{a,b,c},n] returns TridiagonalMatrix[{a,b,c},{n,n}]. ";



ReduceEquations::usage = 
"ReduceEquations[\!\(\(\*StyleBox[\"eqns\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"pivoteqn\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"targeteqn\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"m\",\"TI\"]\)\)] returns the system of equations that results from replacing \!\(\*StyleBox[\"targeteqn\",\"TI\"]\) by \!\(\(\*StyleBox[\"(\",\"TR\"]\)\(\(\(\*StyleBox[\"m\",\"TI\"]\)\(\*StyleBox[\"*\",\"TR\"]\)\(\*StyleBox[\"pivoteqn\",\"TI\"]\)\)\(\*StyleBox[\"+\",\"TR\"]\)\(\*StyleBox[\"targeteqn\",\"TI\"]\)\)\(\*StyleBox[\")\",\"TR\"]\)\). If \!\(\(\*StyleBox[\"targeteqn\",\"TI\"]\)\(\*StyleBox[\"=\",\"TR\"]\)\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\*StyleBox[\"te\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"te\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)\) and \!\(\(\*StyleBox[\"m\",\"TI\"]\)\(\*StyleBox[\"=\",\"TR\"]\)\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\*StyleBox[\"m\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"m\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)\), then equations \!\(\(\(\*StyleBox[\"te\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"te\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\) are replaced by \!\(\(\(\*StyleBox[\"(\",\"TR\"]\)\(\(\(\(\*StyleBox[\"m\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\"*\",\"TR\"]\)\(\*StyleBox[\"pivoteqn\",\"TI\"]\)\)\(\*StyleBox[\"+\",\"TR\"]\)\(\(\*StyleBox[\"te\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\)\(\*StyleBox[\")\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"(\",\"TR\"]\)\(\(\(\(\*StyleBox[\"m\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\"*\",\"TR\"]\)\(\*StyleBox[\"pivoteqn\",\"TI\"]\)\)\(\*StyleBox[\"+\",\"TR\"]\)\(\(\*StyleBox[\"te\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\)\(\*StyleBox[\")\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\). ";

ReduceMatrix::usage = 
"ReduceMatrix[\!\(\(\*StyleBox[\"mat\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"pivotrow\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"targetrow\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"a\",\"TI\"]\)\)] returns the matrix that results from replacing \!\(\*StyleBox[\"targetrow\",\"TI\"]\) by \!\(\(\*StyleBox[\"(\",\"TR\"]\)\(\(\(\*StyleBox[\"a\",\"TI\"]\)\(\*StyleBox[\"*\",\"TR\"]\)\(\*StyleBox[\"pivotrow\",\"TI\"]\)\)\(\*StyleBox[\"+\",\"TR\"]\)\(\*StyleBox[\"targetrow\",\"TI\"]\)\)\(\*StyleBox[\")\",\"TR\"]\)\). If \!\(\(\*StyleBox[\"targetrow\",\"TI\"]\)\(\*StyleBox[\"=\",\"TR\"]\)\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\*StyleBox[\"tr\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"tr\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)\) and \!\(\(\*StyleBox[\"a\",\"TI\"]\)\(\*StyleBox[\"=\",\"TR\"]\)\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\*StyleBox[\"a\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"a\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)\), then rows \!\(\(\(\*StyleBox[\"tr\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"tr\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\) are replaced by \!\(\(\(\*StyleBox[\"(\",\"TR\"]\)\(\(\(\(\*StyleBox[\"a\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\"*\",\"TR\"]\)\(\*StyleBox[\"pivotrow\",\"TI\"]\)\)\(\*StyleBox[\"+\",\"TR\"]\)\(\(\*StyleBox[\"tr\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\)\(\*StyleBox[\")\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"(\",\"TR\"]\)\(\(\(\(\*StyleBox[\"a\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\"*\",\"TR\"]\)\(\*StyleBox[\"pivotrow\",\"TI\"]\)\)\(\*StyleBox[\"+\",\"TR\"]\)\(\(\*StyleBox[\"tr\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\)\(\*StyleBox[\")\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\). ";

ScaleEquation::usage = 
"ScaleEquations[\!\(\(\*StyleBox[\"eqns\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"targeteqn\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"scale\",\"TI\"]\)\)] replaces \!\(\*StyleBox[\"targeteqn\",\"TI\"]\) with \!\(\(\*StyleBox[\"(\",\"TR\"]\)\(\(\*StyleBox[\"scale\",\"TI\"]\)\(\*StyleBox[\"*\",\"TR\"]\)\(\*StyleBox[\"targeteqn\",\"TI\"]\)\)\(\*StyleBox[\")\",\"TR\"]\)\). If \!\(\(\*StyleBox[\"targeteqn\",\"TI\"]\)\(\*StyleBox[\"=\",\"TR\"]\)\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\*StyleBox[\"te\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"te\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)\) and \!\(\(\*StyleBox[\"scale\",\"TI\"]\)\(\*StyleBox[\"=\",\"TR\"]\)\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\*StyleBox[\"s\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"s\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)\), then the equations \!\(\(\(\*StyleBox[\"te\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"te\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\) are replaced by \!\(\(\(\*StyleBox[\"(\",\"TR\"]\)\(\(\(\*StyleBox[\"s\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\"*\",\"TR\"]\)\(\(\*StyleBox[\"te\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\)\(\*StyleBox[\")\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"(\",\"TR\"]\)\(\(\(\*StyleBox[\"s\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\"*\",\"TR\"]\)\(\(\*StyleBox[\"te\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\)\(\*StyleBox[\")\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\). ";

ScaleRow::usage = 
"ScaleRow[\!\(\(\*StyleBox[\"mat\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"targetrow\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"scale\",\"TI\"]\)\)] replaces \!\(\*StyleBox[\"targetrow\",\"TI\"]\) with \!\(\(\*StyleBox[\"(\",\"TR\"]\)\(\(\*StyleBox[\"scale\",\"TI\"]\)\(\*StyleBox[\"*\",\"TR\"]\)\(\*StyleBox[\"targetrow\",\"TI\"]\)\)\(\*StyleBox[\")\",\"TR\"]\)\). If \!\(\(\*StyleBox[\"targetrow\",\"TI\"]\)\(\*StyleBox[\"=\",\"TR\"]\)\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\*StyleBox[\"tr\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"tr\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)\) and \!\(\(\*StyleBox[\"scale\",\"TI\"]\)\(\*StyleBox[\"=\",\"TR\"]\)\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\*StyleBox[\"s\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"s\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)\), then rows \!\(\(\(\*StyleBox[\"tr\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"tr\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\) are replaced by \!\(\(\(\*StyleBox[\"(\",\"TR\"]\)\(\(\(\*StyleBox[\"s\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\"*\",\"TR\"]\)\(\(\*StyleBox[\"tr\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\)\(\*StyleBox[\")\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"(\",\"TR\"]\)\(\(\(\*StyleBox[\"s\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\"*\",\"TR\"]\)\(\(\*StyleBox[\"tr\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\)\(\*StyleBox[\")\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\). ";

ElementaryMatrix3::usage = 
"ElementaryMatrix3[n, rowi, rowj] returns the elementary matrix of size n that interchanges rowi (columni) with rowj (columnj).";

ElementaryMatrix2::usage = 
"ElementaryMatrix2[n, rowi, m] returns the elementary matrix of size n that multiplies rowi (columni) by the scalar m.";

ElementaryMatrix1::usage = 
"ElementaryMatrix1[n, rowi, rowj, m] returns the elementary matrix of size n that adds m * rowi to rowj.";

SameSpanQ::usage = 
"SameSpanQ[\!\(\(\(\*StyleBox[\"list\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"list\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\)] tests whether the two lists have the same span.
SameSpanQ[\!\(\(\(\*StyleBox[\"list\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"list\",\"TI\"]\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"var\",\"TI\"]\)\)] performs the same test for spaces of functions of variable \!\(\*StyleBox[\"var\",\"TI\"]\). ";

SubspaceQ::usage = 
"SubspaceQ[list1,list2] tests whether the span of list1 is a subspace of the span of list2.  SubspaceQ[list1,list2, var] performs the same test for function spaces of functions of var.";

NewQRDecomposition::usage =
"NewQRDecomposition[matA] returns a list {matQ, matR}, where matQ is a matrix with orthonormal columns and matR is an upper triangular matrix such that matA = matQ.matR."; 


MatrixPowers::usage = 
"MatrixPowers[mat,{n1,n2,...}] returns mat raised to the power n1, n2, ... .  MatrixPowers[mat,n] returns MatrixPowers[mat,Sign[n] {1,2,...,n}].";


PermutationMatrix::usage = 
"PermutationMatrix[{c1,c2,...}] returns the identity matrix with its columns reordered so that column 1 is column c1 of I, column 2 is the column c2 of I, ....";

JordanNilpotent::usage = 
"JordanNilpotent[\!\(\*StyleBox[\"n\",\"TI\"]\)] returns the \!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) upper triangular matrix with zeros on the main diagonal and ones on the first superdiagonal. It is the nilpotent part of a Jordan block of size \!\(\*StyleBox[\"n\",\"TI\"]\). ";

JordanBlock::usage = 
"JordanBlock[\!\(\(\*StyleBox[\"\[Alpha]\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\)] returns the \!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) Jordan block with \!\(\*StyleBox[\"\[Alpha]\",\"TI\"]\) on the main diagonal. ";

JordanMatrix::usage = 
"JordanMatrix[\!\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\*StyleBox[\"\[Alpha]\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"n\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)] returns the Jordan matrix having Jordan blocks JordanBlock[\!\(\(\(\*StyleBox[\"\[Alpha]\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"n\",\"TI\"]\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\)], ... . ";


MakeLC::usage=
"MakeLC[list,coeffs] returns a linear combination of the elements of the list whose coefficients are coeffs.  MakeLC[list,a] returns a linear combination of the elements of the list whose coefficients are {a1, a2, ...}.  Setting Subscript -> False uses coefficients {a[1],a[2],...}.";

TakeRow::usage = 
"TakeRow[mat,n] returns the nth rows of mat. Equivalent to mat[[n]] or Flatten[Take[mat,{n}]].
TakeRow[mat,-n]  counts from the end of mat. Equivalent to mat[[-n]] or Flatten[Take[mat,{-n}]].
TakeRow[mat,{n}] returns the nth row of mat as a matrix. It is equivalent to mat[[{n}]] or Take[mat,{n}].
TakeRow[mat,{m,n}] returns the mth and nth rows of mat. It is equivalent to mat[[{m,n}]].
TakeRow[mat,m;;n] returns rows m through n of mat. It is equivalent to mat[[m;;n]] or Take[mat,m;;n].";

TakeColumn::usage = 
"TakeColumn[mat,n] returns the nth column of mat as a vector. It is equaivalent to mat[[All,n]] or Flatten[Take[mat,All,{n}]].
TakeColumn[mat,-n] counts from the end of mat. It is equivalent to mat[[All,-n]] or Flatten[Take[mat,All,{-n}]].
TakeColumn[mat,{n}] returns the nth column of mat as a matrix. It is equivalent to mat[[All,{n}]] or Take[mat,All,{n}].
TakeColumn[mat,{m,n}] returns the mth and nth columns of mat. It is equivalent to mat[[All,{m,n}]].
TakeColumn[mat,m;;n] returns columns m through n of mat. It is equivalent to mat[[All,m;;n]] or Take[mat,All,m;;n].";

DropRow::usage = 
"DropRow[mat,k] drops the first k rows. DropRow[mat,-k] drops the last k rows. DropRow[mat,{k}] drops the k^th row. DropRow[mat,{{k[1]},{k[2]},...}] drops rows k[1], k[2], .... DropRow[mat,{m,n}] drops rows m through n. DropRow[mat,{m,n,s}] drops the m^th through n^th rows in steps of s." ;

DropColumn::usage = 
"DropColumn[mat,k] drops the first k columns. DropColumn[mat,-k] drops the last k columns. DropColumn[mat,{k}] drops the k^th column. DropColumn[mat,{{k[1]},{k[2]}, ...}] drops columns k[1], k[2], ...]. DropColumn[mat,{m,n}] drops columns m through n. DropColumn[mat,{m,n,s}] drops the m^th through n^th columns in steps of s.";

PrependColumn::usage = 
"PrependColumn[mat,vec] prepends the vector vec as the first column of the matrix mat.  PrependColumn[mat,{vec1,vec2,...}] prepends vec1,vec2, ... as the first columns of the matrix. PrependColumn[mat,b] prepends the vector {Subscript[b, 1],Subscript[b, 2],...} as the first column of the matrix. Setting the option Subscript->False prepends the vector {b[1],b[2],...}.";

PrependRow::usage = 
"PrependRow[mat,vec] prepends the vector vec as the first row of the matrix mat.  PrependRow[mat,{vec1,vec2,...}] prepends vec1,vec2, ... as the first rows of the matrix. PrependRow[mat,b] prepends the vector {Subscript[b, 1],Subscript[b, 2],...} as the first row of the matrix. Setting the option Subscript->False prepends the vector {b[1],b[2],...}.";

InterchangeRows::usage = 
"InterchangeRows[mat,m,n] interchanges row m and row n.";

InterchangeColumns::usage = 
"InterchangeColumns[mat,m,n] interchanges column m and column n.";

ZeroVector::usage = 
"ZeroVector[n] returns the zero vector in R^n. ConstantArray[0,n] returns the same result.";

ZeroMatrix::usage = 
"ZeroMatrix[{m,n}] returns the m x n zero matrix.  ZeroMatrix[n] returns the n x n zero matrix. ConstantArray[0, {m,n}] returns the same result as ZeroMatrix[{m,n}].";



TriangularMatrixQ::usage = 
"TriangularMatrixQ[matrix] returns True of the matrix is an upper triangular square matrix, and False otherwise.";


SymbolicRowReduce::usage = 
"SymbolicRowReduce[matA] returns the reduced echelon form of a matrix matA whose only symbolic entries are in its last column. ";

PivotColumns::usage = 
"PivotColumns[matA] returns the column numbers of the pivot columns of the matrix matA.";



Rank::usage = 
"Obsolete. The KnoxPackages command Rank has been replaced by the system command MatrixRank.";

RowSpace::usage = 
"RowSpace[\!\(\*StyleBox[\"mat\",\"TI\"]\)] returns a basis for the subspace spanned by the rows of the matrix \!\(\*StyleBox[\"mat\",\"TI\"]\). ";

GramSchmidt::usage = 
"GramSchmidt[\!\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)] returns the orthogonal set of vectors that results from applying the standard Gram-Schmidt algorithm to the list of vectors. If the list of vectors is dependent, a zero vector is returned in the position corresponding to each dependent vector.
GramSchmidt[\!\(\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"ip\",\"TI\"]\)\)] uses the inner product \!\(\*StyleBox[\"ip\",\"TI\"]\) in applying the Gram-Schmidt algorithm. ";

ProjectVector::usage = 
"ProjectVector[\!\(\(\(\*StyleBox[\"u\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\)] returns \!\(\(\(\(\*StyleBox[\"<\",\"TR\"]\)\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"u\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\)\(\*StyleBox[\">\",\"TR\"]\)\)\(\*StyleBox[\"/\",\"TR\"]\)\(\(\*StyleBox[\"<\",\"TR\"]\)\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\)\(\*StyleBox[\">\",\"TR\"]\)\)\)\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\), the projection of \!\(\(\*StyleBox[\"u\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\) onto \!\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\).
ProjectVector[\!\(\(\(\*StyleBox[\"u\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"ip\",\"TI\"]\)\)] returns the projection of \!\(\(\*StyleBox[\"u\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\) onto \!\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\) using the inner product \!\(\*StyleBox[\"ip\",\"TI\"]\).
ProjectVector[\!\(\(\(\*StyleBox[\"u\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)\)] returns the projection of \!\(\(\*StyleBox[\"u\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\) onto the subspace spanned by \!\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\).
ProjectVector[\!\(\(\(\*StyleBox[\"u\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"ip\",\"TI\"]\)\)] uses the inner product \!\(\*StyleBox[\"ip\",\"TI\"]\) in computing the projection. ";

ProjectVectorON::usage = 
"ProjectVectorON[u, onbasis, ip] projects u onto the subspace with the orthonormal basis onbasis with respect to the inner product ip. ";

ProjectionMatrix::usage = 
"ProjectionMatrix[\!\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)] returns the projection matrix for the projection of \!\(\(\*StyleBox[\"\[DoubleStruckCapitalR]\",\"TR\"]\)\^\(\*StyleBox[\"m\",\"TI\"]\)\) onto the subspace spanned by \!\(\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"1\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\(\(\*StyleBox[\"v\",\"TI\"]\)\&\(\*StyleBox[\"\[RightVector]\",\"TR\"]\)\)\_\(\*StyleBox[\"2\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"...\",\"TI\"]\)\). ";


DiagQuad::usage = 
"DiagQuad[quadratic,{varlist},{newvarlist}] returns a list consisting of three elements: the diagonalized quadratic in the variables specified in newvarlist, the eigenvalues, and the eigenvectors of the quadratic.  If newvarlist is not specified, variables not previously used in the current Mathematica session will be chosen.";

NDiagQuad::usage = 
"NDiagQuad[quadratic,{varlist},{newvarlist}] is similar to DiagQuad except that numerical approximations are used in all calculations.";

CompleteSquare::usage = 
"CompleteSquare[expr, var] completes the square in the variable specified by var.
CompleteSquare[expr,varlist] completes the square in all the variables specified in varlist.";

RandomVector::usage = 
"RandomVector[\!\(\*StyleBox[\"n\",\"TI\"]\)] returns a random \!\(\*StyleBox[\"n\",\"TI\"]\)-vector whose components are Random[].
RandomVector[\!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)] returns a random \!\(\*StyleBox[\"n\",\"TI\"]\)-vector whose components are Random[\!\(\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)]. ";

RandomComplexVector::usage = 
"RandomComplexVector[\!\(\*StyleBox[\"n\",\"TI\"]\)] returns an \!\(\*StyleBox[\"n\",\"TI\"]\)-vector with complex components whose real and imaginary parts are Random[].
 RandomComplexVector[\!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)] returns an \!\(\*StyleBox[\"n\",\"TI\"]\)-vector with complex components whose real and imaginary parts are Random[\!\(\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)]. ";

RandomMatrix::usage = 
"RandomMatrix[\!\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\*StyleBox[\"m\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)] returns an \!\(\(\*StyleBox[\"m\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) matrix with entries Random[].
RandomMatrix[\!\(\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\*StyleBox[\"m\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)] returns an \!\(\(\*StyleBox[\"m\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) matrix with entries Random[\!\(\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)].
RandomMatrix[\!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)] returns a square matrix with entries Random[\!\(\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)]. ";

RandomComplexMatrix::usage = 
"RandomComplexMatrix[\!\(\(\*StyleBox[\"{\",\"TR\"]\)\(\(\*StyleBox[\"m\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)] returns a random \!\(\(\*StyleBox[\"m\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) matrix with complex entries whose real and imaginary parts are Random[].
RandomComplexMatrix[\!\(\(\(\*StyleBox[\"[\",\"TR\"]\)\(\(\*StyleBox[\"m\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\)\(\*StyleBox[\"}\",\"TR\"]\)\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)] returns a random \!\(\(\*StyleBox[\"m\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) matrix with complex entries whose real and imaginary parts are Random[\!\(\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)].
RandomComplexMatrix[\!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)] returns a square matrix. ";

RandomSymmetricMatrix::usage = 
"RandomSymmetricMatrix[\!\(\*StyleBox[\"n\",\"TI\"]\)] returns an \!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) symmetric matrix whose entries are Random[].
RandomSymmetricMatrix[\!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)] returns an \!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) symmetric matrix whose entries are Random[\!\(\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)]. ";

RandomSkewSymmetricMatrix::usage = 
"RandomSkewSymmetricMatrix[\!\(\*StyleBox[\"n\",\"TI\"]\)] returns an \!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) skew-symmetric matrix whose entries are Random[].
RandomSkewSymmetricMatrix[\!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)] returns an \!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) skew-symmetric matrix whose entries are Random[\!\(\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)]. ";

RandomHermitianMatrix::usage = 
"RandomHermitianMatrix[\!\(\*StyleBox[\"n\",\"TI\"]\)] returns an \!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) Hermitian matrix whose real and imaginary parts are Random[].
RandomHermitianMatrix[\!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)] returns an \!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) Hermitian matrix whose real and imaginary parts are Random[\!\(\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)]. ";

RandomSkewHermitianMatrix::usage = 
"RandomSkewHermitianMatrix[\!\(\*StyleBox[\"n\",\"TI\"]\)] returns a skew-Hermitian matrix whose entries have real and imaginary parts Random[].
RandomSkewHermitianMatrix[\!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)] returns a skew-Hermitian matrix whose entries have real and imaginary parts Random[\!\(\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)]. ";

RandomTriangularMatrix::usage = 
"RandomTriangularMatrix[\!\(\*StyleBox[\"n\",\"TI\"]\)] returns an \!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) upper triangular matrix whose nonzero entries are Random[].
RandomTriangularMatrix[\!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)] returns an \!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) upper triangular matrix whose nonzero entries are Random[\!\(\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)]. ";


TriangularMatrix::usage = 
"TriangularMatrix[a,n] returns an n x n upper triangular matrix whose entries are a[i,j].  TriangularMatrix[a,n,k] returns an n x n matrix with zeros below the kth diagonal, with k = 0 being the main diagonal. Setting Subspript -> False will return an unsubscripted array.";

SymmetricArray::usage = 
"SymmetricArray has been renamed SymmetricMatrix.";

SymmetricMatrix::usage = 
"SymmetricMatrix[a,n] returns an n x n symmetric matrix whose entries are a[i,j].";

RandomOrthogonalMatrix::usage = 
"RandomOrthogonalMatrix[\!\(\*StyleBox[\"n\",\"TI\"]\)] returns an \!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) orthogonal matrix whose entries are the result of applying Gram-Schmidt to the rows of the matrix with entries Random[].
RandomOrthogonalMatrix[\!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)] returns an \!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) orthogonal matrix whose entries are the result of applying Gram-Schmidt to the rows of the matrix with entries Random[\!\(\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)]. ";

RandomUnitaryMatrix::usage = 
"RandomUnitaryMatrix[\!\(\*StyleBox[\"n\",\"TI\"]\)] returns an \!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) unitary matrix obtained by orthogonalizing a complex matrix with entries whose real and imaginary parts are Random[].
RandomUnitaryMatrix[\!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)] returns an \!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) unitary matrix obtained by orthogonalizing a complex matrix with entries whose real and imaginary parts are Random[\!\(\(\*StyleBox[\"type\",\"TI\"]\)\(\*StyleBox[\",\",\"TR\"]\)\(\*StyleBox[\"range\",\"TI\"]\)\)]. ";

RandomInvolution::usage = 
"RandomInvolution[n] returns an nxn involution whose entries are Random[].  RandomInvolution[n,type,range] returns an nxn involution whose entries are Random[type, range].";

RandomPermutationMatrix::usage = 
"RandomPermutationMatrix[\!\(\*StyleBox[\"n\",\"TI\"]\)] returns an \!\(\(\*StyleBox[\"n\",\"TI\"]\)\(\*StyleBox[\"x\",\"TR\"]\)\(\*StyleBox[\"n\",\"TI\"]\)\) permutation matrix. ";

Normalized::usage = 
"The option Normalized has been replaced by Normalize.";

CoefficientRange::usage = 
"CoefficientRange -> {p,q} uses random integers between p and q in forming the dependent columns in RandomMatrix.";

VandermondeMatrix::usage=
"VandermondeMatrix[data,n] returns the m by n (m = Length[data]) matrix whose columns are data^0, data^1, ...,data^(n-1).";

LagrangeBasis::usage = 
"LagrangeBasis[data, x] returns the basis for the polynomials of degree Length[data]-1.";

(*
obsolete::Rank = "Obsolete. The KnoxPackages command Rank has been replaced by the system command MatrixRank.";
*)
Message::syntax = "The syntax of this command has changed. Please see the usage message.";

Coordinates::number = "The second argument must be a vector, a list of vectors, or a list of matrices whose entries are numbers.  If the second argument is a list of polynomials, then enter the variable as the third argument.";

Coordinates::lc = "It appears that at least one vector in `1` is not a linear combination of the vectors in `2`.";

Coordinates::dep = "The list of vectors `1` is dependent.";

GramSchmidt::ip = "Dot cannot be used with the given input. Please specify an appropriate inner product.";

PMList::distinct = "The elements of the input list `` must be distinct";

basisinter::size = "All vectors must be the same size.";
(*
obsolete::matE = "matE[i,j,m,n] returnes the m x n matrix whose only nonzero entry was a 1 in the position i,j. 
It has been replaced by UnitMatrix[m,n,i,j]. Note the change in the order of the arguments."
*)
DiagQuad::commonvars = "The specified original and new variables have `` in common, when they should be disjoint.";

DiagQuad::varlists = "The original variables `1` and new variables `2` are lists of unequal lengths, `3` and `4` respectively.";

RandomMatrix::complex = "Use RandomComplexMatrix for a matrix with complex entries.";
RandomMatrix::ranktoobig = "The rank of the matrix can be at most the minimum of the number of rows and columns.";
RandomMatrix::rank = "Rank not a valid option for Real or Complex matrices.";



(*AffineMap::obsolete = "AffineMap has been replaced by NewGeometricTransformation.";
*)

list::empty = "The subspaces intersect in the trivial subspace. ";

projmat::notreal = "`1` must be a real matrix.";

srr::symbolic = "Symbolic entries are allowed only in the last column. Suggest using the KnoxPackages command ReduceMatrix "


Options[GramSchmidt] = {Normalize -> False}//Sort;

Options[RandomMatrix] = {Rank -> {}, CoefficientRange->{-5, 5}}//Sort;	
(*
Options[AffineMap] = {PlotStyle -> {},PointStyle -> {}}//Sort;
*)

Options[ConstraintEqns] = Options[AppendColumn] = Options[PrependColumn] = Options[AppendRow] = Options[PrependRow] = 
	{Subscript -> True}//Sort;

Options[MakeLC] = {Subscript->True}//Sort;

Options[TriangularMatrix] = {Subscript->False}//Sort;

Options[ReduceEquations] = Options[ScaleEquation] = {Variables -> {}}//Sort;

Begin["`Private`"];
(*
Rank[mat_?MatrixQ]:=(Message[obsolete::Rank];MatrixRank[mat])
*)	

BasisIntersection[list1_,list2_]:=
	Module[{vars, mat1, mat2},
	If[list1 === {} || list2 === {}, Return[Message[list::empty]; {}]];
	If[Not[MatrixQ[Join[list1, list2]]],Return[Message[basisinter::size]]];
	vars=Table[b[i],{i,Length[First[list1]]}];
	mat1=CoefficientMatrix[ConstraintEqns[Transpose[list1],b,Subscript->False],vars];
	mat2=CoefficientMatrix[ConstraintEqns[Transpose[list2],b,Subscript->False],vars];
	NullSpace[Join[mat1,mat2]]]

BasisIntersection[span1_List, span__List] :=
	If[MemberQ[Join[span1, Join[span]],{},Infinity], 
		Return[{}],
		If[MatrixQ[Join[span1, Join[span]]],
			Fold[BasisIntersection, span1, {span}],
			Return[Message[basisinter::size]]]
		]

BasisSum[span1_List, span__List] :=
	Module[{mat = Join[span1, Join[span]]},
	If[MatrixQ[mat], 
		ColumnSpace[Transpose[mat]], 
		Return[Message[basisinter::size]]]]




NewLU[mat_] := 
	Module[{matLUD = LUDecomposition[mat], matU, len = Length[mat]}, 
	matU = TriangularMatrix[matLUD[[1]][[#1,#2]] & , len, Subscript->False]; 
	Reverse[{Transpose[PermutationMatrix[matLUD[[2]]]], matU, matLUD[[1]] - matU + IdentityMatrix[len]}]]

LDU[mat_]:=
	Module[{matLUD = LUDecomposition[mat], matU, len = Length[mat], matD}, 
	matU = TriangularMatrix[matLUD[[1]][[#1,#2]] & , len,  Subscript->False]; 
	matD = DiagonalMatrix[Diagonal[matLUD[[1]]]];
	Reverse[{Transpose[PermutationMatrix[matLUD[[2]]]],  (1/Diagonal[matLUD[[1]]]) matU, matD,  matLUD[[1]] - matU + IdentityMatrix[len]}]]

coefficientmatrix[sys_,var_,powers_]:=
  	Coefficient[Expand[sys],var,#1]&/@powers



Coordinates[image_, basis_]:=
	Coordinates[{image}, basis]/;(Length[Dimensions[basis]]==3 && Not[MatrixQ[First[image]]])

Coordinates[image_?VectorQ, basis_]:=
	Coordinates[{image}, basis]

Coordinates[image_, basis_] := 
	Module[{coeffs, lenbasis = Length[basis], data},
	If[MatrixQ[basis] && MatrixRank[basis] < lenbasis,Return[Message[Coordinates::dep, basis]]]; 
	If[VectorQ[Flatten[basis], NumericQ], 
		coeffs = Table[Unique[], {i, lenbasis}]; 	
		data = (RowReduce[AugmentedMatrix[Flatten[#1], coeffs]] & ) /@ 
       		(coeffs . basis - #1 & ) /@ 
        			If[Head[First[image]] === List, image, {image}], 
		Return[Message[Coordinates::number]]];
	If[MatrixRank/@data == lenbasis Table[1,{i,Length[image]}],
		data=(TakeColumn[Take[#1, lenbasis], -1] & ) /@ data,
		Return[Message[Coordinates::lc,image,basis]]];
	If[Length[data]==1, First[data],data]]



Coordinates[image_List, basis_List, var_Symbol, opts___] := 
	Module[{coeffs, maxorder, orders, mat, trig, nimage, nbasis, eqns, data, pvars, patternvars, amat, coords}, 
{nimage, nbasis} = TrigReduce/@{image,basis};

	If[Select[nbasis, PolynomialQ[#1, var] & ] === nbasis && Select[nimage, PolynomialQ[#1, var] & ] === nimage, 
		coeffs = Table[Unique[], {i, Length[basis]}]; 
		maxorder = Max[(PolynomialDegree[#1, var] & ) /@ nbasis]; 
		If[Max[(PolynomialDegree[#1, var] & ) /@ nimage] > maxorder, 
			Return[Message[Coordinates::lc, image, basis]]]; 
		orders = Range[0, maxorder]; 
		mat = (RowReduce[AugmentedMatrix[#1, coeffs]] & ) /@ 
			((coefficientmatrix[#1, var, orders] & ) /@ 
				Collect[#1, var] & ) /@ (coeffs . nbasis - #1 & ) /@ nimage;
		Which[
			Max[MatrixRank /@ mat] < Length[basis], Return[Message[Coordinates::dep, basis]], 
      			Max[MatrixRank /@ mat] == Length[basis], 
					(Take[TakeColumn[#1, -1],Length[basis]] & ) /@ mat,
			True, Return[Message[Coordinates::lc, image, basis]]], 

	trig = Trig /. {opts} /. Trig->True;
	{nimage,nbasis} = If[trig, TrigReduce[ExpToTrig[#]]& /@ {image,basis}, {image,basis}];
(*12-14-11 Handles the case where the list of functions contains a constant function but the basis does not. *)
	If[(ConstantTerm/@nimage)!=ZeroVector[Length[nimage]] && ConstantTerm/@nbasis==ZeroVector[Length[nbasis]],Return[Message[Coordinates::lc, image, basis]]]; 
	coeffs = Table[a[i, j], {i, 1, Length[image]}, {j, 1, Length[basis]}]; 
	eqns = coeffs . nbasis - nimage;  
	data = Union[Replace[Flatten[Expand[nbasis] //. (a_) + (b_) -> {a, b}], 
			{(b_)?NumericQ*(a_) -> a, _?NumericQ -> 1},1]]; 
	pvars = Table[{Unique[], _}, {i, Length[data]}]; 
	patternvars = (Optional[Pattern @@ #1] & ) /@ pvars; 
	amat = Cases[Collect[Expand[eqns], data,Simplify], Expand[patternvars . data] -> First /@ pvars, 1]; 
	If[amat == {}, Return[Message[Coordinates::lc, image, basis]]];
	If[Last[Dimensions[amat]] < Last[Dimensions[coeffs]],  
		amat = {Flatten[Join[amat, ZeroVector[Last[Dimensions[coeffs]]- Last[Dimensions[amat]]]]]}]; 
		coords = (Take[#1, Length[nbasis]] & ) /@ Last /@ Transpose /@ RowReduce /@ 
			MapThread[AugmentedMatrix[#1, #2] & , {amat, coeffs}];
		If[MatrixQ[coords,NumericQ], coords, Return[Message[Coordinates::lc, image, basis]]]]]

Coordinates[image_, basis_List, var_Symbol, opts___] := Coordinates[{image},basis,var,opts]



StandardBasisMatrices[{m_?IntegerQ,n_?IntegerQ}] := Map[Partition[#,n]&,IdentityMatrix[m n]]

StandardBasisMatrices[m_?IntegerQ] := StandardBasisMatrices[{m,m}]

SBMatrices[size_]:=StandardBasisMatrices[size];

StandardBasisPolys[x_, n_?IntegerQ] := Table[x^i,{i,0,n}]

SBPolys[x_, n_?IntegerQ] := StandardBasisPolys[x, n]

StandardBasisTrigPolys[x_, n_?IntegerQ] := Flatten[{1,Table[{Cos[i x],Sin[i x]},{i,1,n}]}]

SBTPolys[x_, n_]:= StandardBasisTrigPolys[x, n]



(*matE[m_, n_, i_, j_] := Message[obsolete::matE]
matE[n_, i_, j_] := matE[n, n, i, j]*)

(*UnitMatrix[m_, n_, i_, j_] := ReplacePart[ZeroMatrix[{m, n}], 1, {i, j}]*)
UnitMatrix[m_, n_, i_, j_] := SparseArray[{i,j}->1,{m,n}]//Normal
UnitMatrix[n_, i_, j_] := UnitMatrix[n, n, i, j]

StandardBasisSMatrices[n_] := Flatten[Table[If[i == j, UnitMatrix[n, i, i], UnitMatrix[n, i, j] + UnitMatrix[n, j, i]], {i, 1, n}, {j, i, n}],1]

SBSMatrices[n_] := StandardBasisSMatrices[n];

StandardBasisSSMatrices[n_] := Flatten[Table[UnitMatrix[n, i, j] - UnitMatrix[n, j, i], {i, 1, n - 1}, {j, i + 1, n}],1]

SBSSMatrices[n_] := StandardBasisSSMatrices[n];

StandardBasisTraceZeroMatrices[n_] := 
	With[{temp = Flatten[Table[UnitMatrix[n, i, j], {i, 1, n}, {j, i + 1, n}], 1]}, 
		Join[Table[-UnitMatrix[n, 1, 1] + UnitMatrix[n, i, i], {i, 2, n}], 
			temp, Transpose /@ temp]]

SBTZMatrices[n_]:= StandardBasisTraceZeroMatrices[n]

StandardBasisDiagonalMatrices[n_]:=
	Table[UnitMatrix[n, i, i], {i, 1, n}]
	
SBDMatrices[n_] := StandardBasisDiagonalMatrices[n]


ChangeBasis[smat_?MatrixQ, vBasis_List, wBasis_List] := 
	DropColumn[RowReduce[AppendColumn[Transpose[wBasis],Transpose[smat.Transpose[vBasis]]]], Length[wBasis]]
  
ChangeBasis[smat_?MatrixQ, vBasis_List] := 
	ChangeBasis[smat,vBasis,vBasis]

ChangeBasis[smat_?MatrixQ, vBasis_List, wBasis_List, x_] := 
	Module[{matM},
	matM = Transpose[Coordinates[wBasis,vBasis,x]];
	Inverse[matM].smat.matM]



FindMatrix[vValues_?(MatrixQ[#,NumericQ]&), wBasis_?(MatrixQ[#,NumericQ]&)]:=
	Transpose[Coordinates[vValues, wBasis]]
  	(*DropColumn[RowReduce[AppendColumn[Transpose[wBasis],vValues]],Length[wBasis]]*)
	



FindMatrix[expr_List, vars:{___Symbol | ___Subscript},  vBasis_List]:= 
	(Message[Message::syntax];FindMatrix[expr, vBasis, vBasis, vars])

FindMatrix[expr_List,  vBasis_List, vars:{___Symbol | ___Subscript}]:= 
	FindMatrix[expr, vBasis, vBasis, vars]

FindMatrix[expr_List, vars:{___Symbol | ___Subscript}, vBasis_List, wBasis_List]:=
	(Message[Message::syntax];FindMatrix[expr, vBasis, wBasis, vars])
	
FindMatrix[expr_List, vBasis_List, wBasis_List, vars:{___Symbol | ___Subscript}]:=	
  	DropColumn[
		RowReduce[
			AppendColumn[Transpose[wBasis],expr/.PointsToRules[vBasis, vars]]],
		Length[wBasis]]


FindMatrix[expr_, vBasis_List, wBasis_List, var_Symbol, opts___]:= 
	Module[{images = expr /@ vBasis}, 
	Transpose[
  		If[FreeQ[Flatten[{images, wBasis}], var],
			Coordinates[images, wBasis],
			Coordinates[images, wBasis, var, opts]]]
  ]

FindMatrix[expr_, vBasis_List, wBasis_List]:= FindMatrix[expr, vBasis, wBasis, Unique[x]]

FindMatrix[expr_, vBasis_List, var___Symbol, opts___]:= FindMatrix[expr, vBasis, vBasis, var, opts]
  

FindStandardMatrix[vValues_,vBasis_]:=
  Drop[Transpose[RowReduce[AppendColumn[vBasis,Transpose[vValues]]]],Length[vBasis]]

	
TridiagonalMatrix[{a_List, b_List, c_List}] :=
	Normal[SparseArray[{Band[{2, 1}] -> a, Band[{1, 1}] -> b, Band[{1, 2}] -> c}, Length[b]]] /; (Length[a] == Length[c] == Length[b] - 1)

TridiagonalMatrix[{a_, b_, c_}, {m_, n_}] := 
 Normal[SparseArray[{Band[{2, 1}] -> a, Band[{1, 1}] -> b, Band[{1, 2}] -> c}, {m, n}]]
 
TridiagonalMatrix[{a_, b_, c_}, n_] := 
 Normal[SparseArray[{Band[{2, 1}] -> a, Band[{1, 1}] -> b, Band[{1, 2}] -> c}, n]]	

ReduceEquations[eqns:{__Equal}, pivoteqn_?(IntegerQ[#] && Positive[#]&), targeteqn_?(VectorQ[#,(Positive[#] && IntegerQ[#]&)]&), multiples_?(VectorQ[#,NumericQ]&), opts___?OptionQ] :=
	Fold[ReduceEquations[#1,pivoteqn,Sequence @@ #2, opts]&, eqns, Transpose[{targeteqn,multiples}]]

ReduceEquations[eqns:{__Equal}, pivoteqn_?(IntegerQ[#]&&Positive[#]&), targeteqn_?(IntegerQ[#]&&Positive[#]&), 
		multiple_, opts___?OptionQ] :=
	Module[{expr, vars, const},
	expr = Simplify[multiple eqns[[pivoteqn]] + eqns[[targeteqn]]/.a_== b_ -> a - b];
	vars = Variables /. {opts} /. Options[ReduceEquations];
	vars = If[vars === {}, Union @@ Map[Variables,eqns/.a_== b_ -> a - b], vars];
	const = ConstantTerm[expr, vars];
	DeleteCases[ReplacePart[eqns, Collect[expr - const,vars] == -const, targeteqn],True]]

ReduceMatrix[(mat_)?MatrixQ, pivot_?(IntegerQ[#] && Positive[#]&), target_?(VectorQ[#,(Positive[#] && IntegerQ[#]&)]&), multiples_?VectorQ] :=
	Fold[ReduceMatrix[#1, pivot, Sequence @@ #2]&, mat, Transpose[{target,multiples}] ]

ReduceMatrix[(mat_)?MatrixQ, pivot_?(IntegerQ[#] && Positive[#]&), target_?(IntegerQ[#] && Positive[#]&), multiple_] :=
	ReplacePart[mat, multiple mat[[pivot]] + mat[[target]], target]
(*Probably should replace ReplacePart syntax by its new tamplate. 06-24-17*)


ScaleEquation[eqns:{__Equal}, enumbers_?(VectorQ[#,(Positive[#] && IntegerQ[#]&)]&), multipliers_?VectorQ, opts___?OptionQ] :=
	Fold[ScaleEquation[#1,Sequence @@ #2, opts]&, eqns, Transpose[{enumbers,multipliers}]]

ScaleEquation[eqns:{__Equal}, i_?(IntegerQ[#] && Positive[#]&), c_, opts___?OptionQ] :=
	Module[{expr, const, vars},
	expr = Expand[c*(eqns[[i]] /. a_ == b_ -> a - b)];
	vars = Variables /. {opts} /. Options[ScaleEquation];
	vars = If[vars === {}, Union @@ Map[Variables,eqns/.a_== b_ -> a - b], vars];
	const = ConstantTerm[expr, vars];
	ReplacePart[eqns, expr - const == -const , i]
]

ScaleRow[mat_?MatrixQ, rows_?(VectorQ[#,(Positive[#] && IntegerQ[#]&)]&), multipliers_?VectorQ] :=
	Fold[ScaleRow[#1,Sequence @@ #2]&, mat,Transpose[{rows,multipliers}]]


ScaleRow[mat_?MatrixQ, row_?(IntegerQ[#] && Positive[#]&), c_] :=
	ReplacePart[mat, c mat[[row]] , row]

ElementaryMatrix3[n_, i_, j_] := Swap[IdentityMatrix[n], i, j]

ElementaryMatrix2[n_, i_, m_] := ScaleRow[IdentityMatrix[n], i, m]

ElementaryMatrix1[n_, i_, j_, m_] := ReduceMatrix[IdentityMatrix[n], i, j, m]


SameSpanQ[list1:{__?MatrixQ}, list2:{__?MatrixQ}] := SameSpanQ[Flatten/@list1,Flatten/@list2]

(*
SameSpanQ[list1_List, list2_List] :=
	Select[RowReduce[list1],nonzerotest[][#]&] == 
		Select[RowReduce[list2],nonzerotest[][#]&]
*)

SameSpanQ[list1_, list2_] := 
	MatrixRank[Flatten[{list1, list2}, 1]] == MatrixRank[list2] == MatrixRank[list1]

SameSpanQ[list1_, list2_, var___] := 
	MatrixQ[Coordinates[list1, list2, var]] && MatrixQ[Coordinates[list2, list1, var]]

(*New 6-23-17*)
SubspaceQ[{list1__?MatrixQ}, {list2__?MatrixQ}] := 
	SubspaceQ[Flatten[{list1},1], Flatten[{list2},1]]
	
SubspaceQ[list1_, list2_] := 
	MatrixRank[Flatten[{list1,list2},1]] == MatrixRank[list2]

SubspaceQ[list1_, list2_, var_, opts___] := 
	MatrixQ[Coordinates[list1, list2, var, opts]] 

NewQRDecomposition[mat_]:=
	Module[{matQ, matR},
	{matQ,matR} = QRDecomposition[mat];
	{Transpose[matQ],matR}
]




	
MatrixPowers[mat_?MatrixQ,powers_List] := MatrixPower[mat,#]& /@ powers

MatrixPowers[mat_?MatrixQ,num_?NumberQ] := MatrixPowers[mat,Sign[num] Range[Abs[num]]]



PermutationMatrix[list_List] := 
	If[Length[Union[list]]==Length[list], Transpose[IdentityMatrix[Length[list]][[list]]], Return[Message[PMList::distinct,list]]]

JordanNilpotent[n_] := Table[Switch[j, i + 1,1,_,0],{i,n},{j,n}]

JordanBlock[a_,n_] := a IdentityMatrix[n] + JordanNilpotent[n]
JordanBlock[{a_,n_}] := JordanBlock[a,n]

JordanMatrix[data:{{_,_}...}] := 
	Module[{sizes,blocks},
	sizes = {0,FoldList[Plus,Last[First[data]],Rest[Last[Transpose[data]]]]}//Flatten;
	blocks = MapThread[AppendRow[PrependRow[JordanBlock[#1],
		Table[ZeroVector[Last[#1]],{#2}]],
		Table[ZeroVector[Last[#1]],{Last[sizes] - (#2 + Last[#1])}]]&,{data,Drop[sizes,-1]}];
	Fold[AppendColumn[#1,Transpose[#2]]&,First[blocks],Rest[blocks]]	
	]


(*Changed on 5-27-11 Removed Hold on first argument.*)
AugmentedMatrix[{}, vars_] := {}

AugmentedMatrix[matA_List == matB_List, vars_] :=
	AugmentedMatrix[matA - matB, vars]

AugmentedMatrix[mat_, vars_] := 
	With[{temp = CoefficientArrays[Flatten[Thread /@ mat], vars]}, 
		Normal[Transpose[Join[Transpose[temp[[2]]], -{temp[[1]]}]]]]





(* 
AugmentedMatrix[{}, vars_] := {}

(*AugmentedMatrix[eqn_Equal, vars_]:= AugmentedMatrix[{eqn},vars]*)

AugmentedMatrix[expr_Equal, vars_] := 
	AugmentedMatrix[Evaluate[Unevaluated[expr][[1]]-Unevaluated[expr][[2]]], vars]

AugmentedMatrix[expr_, vars_] := 
	AugmentedMatrix[{expr}, vars] /; Not[Head[expr]===List]
	
(*AugmentedMatrix[mat_?MatrixQ, vars_?VectorQ] := 
	AugmentedMatrix[Flatten[Thread /@ Thread[mat]], vars]
*)
AugmentedMatrix[mat_, vars_] := 
	With[{temp = CoefficientArrays[Flatten[Thread /@ mat], vars]}, 
		Normal[Transpose[Join[Transpose[temp[[2]]], -{temp[[1]]}]]]]
*)

CoefficientMatrix[{}, vars_] := {}

CoefficientMatrix[matA_List == matB_List, vars_] :=
	CoefficientMatrix[matA - matB, vars]
	
(*CoefficientMatrix[mat_?MatrixQ, vars_?VectorQ] := 
	CoefficientMatrix[Flatten[Thread /@ Thread[mat]], vars]
*)
CoefficientMatrix[mat_, vars_] := Normal[Last[CoefficientArrays[Flatten[Thread /@ mat],vars]]]/;Not[FreeQ[mat, Alternatives @@ vars]]
   


ConstraintEqns[(mat_)?MatrixQ, (b_)?VectorQ] := 
  Module[{amat, rank = MatrixRank[mat], dim = Dimensions[mat], consts}, 
	amat = SymbolicRowReduce[AppendColumn[mat, b]] /. (a_.)*(s_Plus) -> s; 
	If[rank < dim[[1]], 
    		amat = Flatten[TakeColumn[Drop[amat, rank], -1]]; 

		consts = (-ConstantTerm[#1] & ) /@ amat; 

		Thread[amat + consts == consts], 
		{}]]


ConstraintEqns[(mat_)?MatrixQ, b_Symbol, opts___?OptionQ] := 
	Module[{subscript},
	subscript = Subscript /. {opts} /. Options[ConstraintEqns];
  	ConstraintEqns[mat, 
		If[subscript,
			Map[Subscript[b, #]&, Range[Dimensions[mat][[1]]]],
  			Array[b, Dimensions[mat][[1]]]]]]


MakeLC[list_List, a_Symbol, opts___?OptionQ]:=
  Module[{subscript},
    subscript=Subscript/.{opts}/.Options[MakeLC];
    If[subscript,
      MakeLC[list, Map[Subscript[a,#]&,Range[Length[list]]]], MakeLC[list,Array[a,Length[list]]]]]

MakeLC[list_?MatrixQ, coeffs_?VectorQ] := Transpose[list].coeffs

MakeLC[list_List, coeffs_?VectorQ] := coeffs.list







TakeRow[mat_?MatrixQ,n:{{_Integer}...}] := mat[[Flatten[n]]]
TakeRow[mat_?MatrixQ, rest_] := mat[[rest]]


TakeColumn[mat_?MatrixQ, n:{{_Integer}...}]:= mat[[All,Flatten[n]]]
TakeColumn[mat_?MatrixQ, rest_] := mat[[All, rest]]

DropRow[mat_?MatrixQ,n:{{_Integer}...}] := mat[[Complement[Range[Length[mat]],Flatten[n]]]]
DropRow[mat_?MatrixQ,n_] := Drop[mat,n]

DropColumn[mat_?MatrixQ,rest_]:= Transpose[DropRow[Transpose[mat],rest]]

AppendColumn[mat_?MatrixQ,{}] := mat
AppendColumn[mat_?MatrixQ,{{}..}] := mat
AppendColumn[mat_?MatrixQ,column_?VectorQ] := AppendColumn[mat,{column}]
AppendColumn[mat_?MatrixQ, b_Symbol, opts___?OptionQ] :=
	Module[{subscript},
	subscript = Subscript /. {opts} /. Options[ConstraintEqns];
  	AppendColumn[mat, 
		If[subscript,
			Map[Subscript[b, #]&, Range[Length[mat]] ],
  			Array[b, Length[mat]]]]
	]
AppendColumn[mat_?MatrixQ,column_?MatrixQ] := Join[mat,Transpose[column],2]/;
					SameQ @@ {First[Dimensions[mat]],Last[Dimensions[column]]}



PrependColumn[mat_?MatrixQ,{}] := mat
PrependColumn[mat_?MatrixQ, column_?VectorQ] := Join[Transpose[{column}],mat,2]
PrependColumn[mat_?MatrixQ, b_Symbol, opts___?OptionQ] := 
	Module[{subscript},
	subscript = Subscript /. {opts} /. Options[ConstraintEqns];
  	PrependColumn[mat, 
		If[subscript,
			Map[Subscript[b, #]&, Range[Length[mat]] ],
  			Array[b, Length[mat]]]]
	]
PrependColumn[mat_?MatrixQ, column_?MatrixQ] := Join[Transpose[column],mat,2]/;
					SameQ @@ {First[Dimensions[mat]],Last[Dimensions[column]]}

AppendRow[mat_?MatrixQ,{}] := mat					
AppendRow[mat_?MatrixQ,row_?VectorQ] := Join[mat,{row}]
AppendRow[mat_?MatrixQ,{{}..}] := mat
AppendRow[mat_?MatrixQ,row_?MatrixQ] := Join[mat,row]/;SameQ @@ {Last[Dimensions[mat]],Last[Dimensions[row]]}
AppendRow[mat_?MatrixQ, b_Symbol, opts___?OptionQ] := 
	Module[{subscript},
	subscript = Subscript /. {opts} /. Options[ConstraintEqns];
  	AppendRow[mat, 
		If[subscript,
			Map[Subscript[b, #]&, Range[Dimensions[mat][[2]]] ],
  			Array[b, Dimensions[mat][[2]]]]]
	]

(*PrependRow[mat_?MatrixQ, sym:{_Symbol..},opts___?OptionQ] := Fold[PrependRow[#1, #2, opts]&, mat, sym]*)
PrependRow[mat_?MatrixQ,{}] := mat
PrependRow[mat_?MatrixQ,row_?MatrixQ] := Join[row,mat]
PrependRow[mat_?MatrixQ,row_List] := Join[{row},mat]
PrependRow[mat_?MatrixQ, b_Symbol, opts___?OptionQ] := 
	Module[{subscript},
	subscript = Subscript /. {opts} /. Options[ConstraintEqns];
  	PrependRow[mat, 
		If[subscript,
			Map[Subscript[b, #]&, Range[Dimensions[mat][[2]]] ],
  			Array[b, Dimensions[mat][[2]]]]]
	]


InterchangeRows[mat_?MatrixQ, m_Integer,n_Integer] := 
	Swap[mat,m,n]
	
InterchangeColumns[mat_?MatrixQ,m_Integer?Positive,n_Integer?Positive] := 
	Transpose[Swap[Transpose[mat],m,n]]
	
	
ZeroVector[n_Integer?Positive] := ConstantArray[0,n];

ZeroMatrix[{m_Integer?Positive,n_Integer?Positive}] := ConstantArray[0, {m,n}]
ZeroMatrix[n_Integer?Positive | {n_Integer?Positive}]  := ZeroMatrix[{n,n}]

NewGeometricTransformation[obj_Graphics3D, trans_, opts___?OptionQ] :=
 Graphics3D[GeometricTransformation[obj[[1]], trans], opts, PlotRange->All, obj[[2]]]

NewGeometricTransformation[obj_Cuboid|Sphere, trans_, opts___?OptionQ] :=
 Graphics3D[GeometricTransformation[obj, trans], opts]

NewGeometricTransformation[obj_Graphics, trans_, opts___?OptionQ] :=
 Graphics[GeometricTransformation[obj[[1]], trans], opts, PlotRange->All, obj[[2]]]

NewGeometricTransformation[obj_, trans_, opts___?OptionQ] :=
 Graphics[GeometricTransformation[obj, trans], opts]

(*
AffineMap[object_SurfaceGraphics,rest__] := 
	AffineMap[Graphics3D[object],rest]
	
AffineMap[object_Graphics | object_Graphics3D, mat_?SquareMatrixQ, trans___?VectorQ, opts___Rule] := 
Module[{gopts,ptopts},
{gopts,ptopts} = {PlotStyle,PointStyle} /. {opts} /. Options[AffineMap];
Show[Normal[object] /. 
			{Line[data_] 				:> Flatten[{gopts,Line[Transpose[mat.Transpose[data] + trans]]}],
		 	 Polygon[data_] 			:> Polygon[Transpose[mat.Transpose[data] + trans]],
		 	 {style___,Point[data_]} 	:> Flatten[{ptopts,style,Point[mat.data + trans]}]},
		 	 	Axes->True,PlotRange->Automatic]]
*)
(*
AffineMap[anything___]:=Message[AffineMap::obsolete]
*)


TriangularMatrixQ[mat_?SquareMatrixQ] := 
   mat === TriangularMatrix[mat[[#1,#2]]&, Length[mat]]


SymbolicRowReduce[matA_]:=
	If[MatrixQ[DropColumn[matA,-1],NumericQ],
		Simplify[RowReduce[matA,ZeroTest->(Not[TrueQ[Unequal[N[#],0]]]&)]],
		Return[Message[srr::symbolic];matA]]


PivotColumns[matrix_?MatrixQ ] :=
	firstnonzero[RowReduce[matrix]]

ColumnSpace[matrix_?MatrixQ] :=
	Transpose[matrix] [[ PivotColumns[matrix] ]]


RowSpace[matrix_?MatrixQ] := 
	Block[{reduced = RowReduce[matrix]},
	reduced[[ Range[Length[firstnonzero[reduced]]] ]]
]

LeftNullSpace[mat_] := 
	Module[{vars = Array[b,Length[mat]]}, 
	CoefficientMatrix[ConstraintEqns[mat,vars],vars]]



CompleteSquare[lhs_ == rhs__, vars_]:= CompleteSquare[lhs-rhs, vars] == 0

CompleteSquare[poly_, vars_] := 
  Module[{newpoly, varslist, const1, const}, 
  	varslist = Flatten[{vars}];
    If[! PolynomialQ[poly, varslist], Return@Message[Poly::notpoly, poly, vars]];
    If[PolynomialDegree[poly, varslist] > 2, Return@Message[Poly::degree, poly, 2, vars]];
    const1 = ConstantTerm[poly, varslist];
    newpoly = Collect[poly - const1, varslist, Simplify];
    newpoly = 
      Fold[#1 /. a_. #2^2 + b_. #2 -> a (#2 + b/a/2)^2 - b^2/a/4 &, newpoly, varslist];
    const = If[AtomQ[newpoly],0, Select[newpoly,FreeQ[#,Alternatives[Sequence @@ varslist]]& ]];
    newpoly = newpoly - const + Simplify[const + const1]]


GramSchmidt[spanset_?MatrixQ, opts___?OptionQ] := 
	Module[{normalize},
	normalize = Normalize /. {opts} /. Options[GramSchmidt];
	If[normalize,
		Orthogonalize[spanset, FilterRules[{opts},Options[Orthogonalize]]//Evaluate],
		Fold[Flatten[{#1, {#2 - ProjectVector[#2, #1]}}, 1] &,{First[spanset]},Rest[spanset]]
		]
	]

GramSchmidt[spanset_List, opts___?OptionQ] := 	(Message[GramSchmidt::ip])
		
GramSchmidt[spanset_List, ip_, opts___?OptionQ] := 
	Module[{normalize},
	normalize = Normalize /. {opts} /. Options[GramSchmidt];
	If[normalize,
		Orthogonalize[spanset, ip, FilterRules[{opts},Options[Orthogonalize]]//Evaluate],
		Fold[Flatten[{#1, {#2 - ProjectVector[#2, #1, ip]}}, 1] &,{First[spanset]},Rest[spanset]]
		]
	]
	

(* Used in PlotProjection3D and related commands. Assumes that onbasis is an orthonormal basis. 
	Useful when an onbasis has already been computed. *)
ProjectVectorON[vecx_, onbasis_List, ip_: (Conjugate[#1].#2 &)] := 
	Apply[Plus, Map[ip[#, vecx] # &, onbasis]] // Simplify
	
ProjectVector[vecx_?VectorQ, vecy_?VectorQ, ip_: (Conjugate[#1].#2 &)] := 
	If[Length[vecx] == Length[vecy],
		Projection[vecx, vecy, ip],
		Return[Message[Projection::prnv]]]
		
ProjectVector[vecx_?MatrixQ, vecy_?MatrixQ, ip_] := 
	If[Length[Flatten[vecx]] == Length[Flatten[vecy]],
		Projection[vecx, vecy, ip],
		Return[Message[Projection::prnv]]]

ProjectVector[vecx_, spanset_, ip_: (Conjugate[#1].#2 &)] := 
	Module[{spansetlist},
	spansetlist = If[Head[spanset] === List, spanset, {spanset}];
	Apply[Plus, Map[ip[#, vecx] # &, Orthogonalize[spansetlist, ip]]]// Simplify]



(* Replaced ConjugateTranspose by Transpose and added condition that the matrix be real. 12-30-2014*)
ProjectionMatrix[spanset_] :=
	If[MatrixQ[spanset, NumericQ[#] && Not[MatchQ[#, _Complex]] &],
		With[{matrix = Transpose[Orthogonalize[spanset]]}, matrix.Transpose[matrix]],
	Return[Message[projmat::notreal, spanset]]]
	
	
	
(* 12-11-92  Changed output to {diagquad,evalues,evectors}  *)
DiagQuad[quadratic_, vars_List, newvars_List] :=
	Block[{quad = quadratic//Expand, length = Length[vars],
		symmat,evalues,evectors,linearterms,transformlinear},
		
			 		(* Error-checking of the input:  *)
	If[!PolynomialQ[quadratic, vars], Return @ 
		Message[Poly::notpoly, quadratic, vars] ];
		
 	If[PolynomialDegree[quadratic, vars] > 2, Return @
		Message[Poly::degree, quadratic,2,vars] ];
		
	If[Length[vars] != Length[newvars], Return @ 
		Message[DiagQuad::varlists, vars, newvars, length,Length[newvars]] ];
		
	If[Intersection[vars, newvars] =!= {}, Return @ 
		Message[DiagQuad::commonvars, Intersection[vars, newvars]] ];
		
					(* Begin diagonalization routine:  *)
	symmat = Table[
			If[i != j,
				Coefficient[quad,vars[[i]] vars[[j]]]/2,
			  	Coefficient[quad,vars[[i]] vars[[j]]]],
			{i,length},{j,length}];

	{evalues,evectors} = Eigensystem[symmat]//Chop;

	If[Chop[Det[N[evectors]]] < 0, {evalues,evectors} = Swap[#,1,2]& /@ {evalues,evectors}];
	
	If[Not[FreeQ[evectors, Root]], evectors = N[evectors]];	

	evectors = Orthogonalize[evectors];

	linearterms = quad - Expand[vars.symmat.vars];
	transformlinear = Map[Coefficient[linearterms,#]&,vars].Transpose[evectors].newvars;

	{evalues.(newvars^2) + transformlinear + ConstantTerm[linearterms],evalues,evectors}//Chop
]
	
	
DiagQuad[quadratic_, vars_List] := 
	Block[{newvars = Map[Unique[ToString[#]]&,vars]},
		DiagQuad[quadratic, vars, newvars]]
	

NDiagQuad[quadratic_, vars_List, newvars_List] :=
	DiagQuad[1. quadratic//Expand//N, vars//N, newvars]
	

NDiagQuad[quadratic_, vars_List] := 
	Block[{newvars = Map[Unique[ToString[#]]&,vars]},
		DiagQuad[1. quadratic//Expand//N, vars//N, newvars]]
	

RandomVector[n_Integer?Positive, type_:Real, range_:{0,1}] :=
	Table[Random[type, range], {n}]

RandomVector[0, type_:Real, range_:{0,1}] := {}

RandomComplexVector[n_Integer?Positive, type_:Real, range_:{0,1}] :=
	Table[Random[type, range] + I Random[type, range] , {n}]

RandomComplexVector[0, type_:Real, range_:{0,1}] := {}




RandomMatrix[{m_,n_}, type_Symbol:Real, range_List:{0,1}, opts___Rule] := 
	Block[{matrank,crange,mat},
	If[type === Complex, Return @ Message[RandomMatrix::complex]];
	{matrank, crange} = {Rank, CoefficientRange} /. {opts} /. Options[RandomMatrix];
If[matrank == 0, Return[ZeroMatrix[{m, n}]]];
	If[matrank === {}, 
		Table[Random[type, range],{m},{n}],
		If[type =!= Integer, Return @ Message[RandomMatrix::rank]];
		If[matrank > Min[m,n], Return @ Message[RandomMatrix::ranktoobig]];
		mat = Table[Random[type, range],{matrank},{n}];
		While[MatrixRank[mat] != matrank, 
				mat = Table[Random[type,range],{matrank},{n}]];
		If[matrank < m,
			mat = AppendRow[mat,Table[Random[type,crange],{m-matrank},{matrank}].mat]];
		Part[mat,Map[Last,Sort[Table[{Random[],i},{i,m}]]]]]
]

RandomMatrix[n_Integer?Positive,rest___] := 
	RandomMatrix[{n,n},rest]
	
	
RandomComplexMatrix[{m_,n_},type_Symbol:Real,range_List:{0,1},opts___Rule] := 
	Block[{matrank,crange,mat},
	{matrank,crange} = {Rank,CoefficientRange} /. {opts} /. Options[RandomMatrix];

	If[matrank === {},
		Table[Random[type,range] + I Random[type,range],{m},{n}],
		If[type =!= Integer, Return @ Message[RandomMatrix::rank]];
		If[matrank > Min[m,n],Return @ Message[RandomMatrix::ranktoobig]];
		mat = Table[Random[type,range] + I Random[type,range],{matrank},{n}];
		While[MatrixRank[mat] != matrank, 
			mat = Table[Random[type,range] + I Random[type,range],{matrank},{n}]];
		If[matrank < m,
			mat = AppendRow[mat,Table[Random[type,crange] + I Random[type,crange],{m-matrank},{matrank}].mat]];
		Part[mat,Map[Last,Sort[Table[{Random[],i},{i,m}]]]]]
]	

RandomComplexMatrix[n_Integer?Positive,rest___] := 
	RandomComplexMatrix[{n,n},rest]





RandomSymmetricMatrix[n_Integer?Positive, type_:Real, range_:{0,1}] :=
	Module[ {lower, diagonal},
	lower = Table[ RandomVector[j - 1, type, range] ~Join~
		Table[0, {n - (j - 1)}], {j, 1, n}];
	diagonal = DiagonalMatrix[RandomVector[n, type, range]];
	lower + Transpose[lower] + diagonal
]

RandomSkewSymmetricMatrix[n_Integer?Positive, type_:Real, range_:{0,1}] :=
	Module[ {lower},
	lower = Table[ RandomVector[j - 1, type, range] ~Join~
		Table[0, {n - (j - 1)}], {j, 1, n}];
	lower - Transpose[lower] 
]

RandomHermitianMatrix[n_Integer?Positive, type_:Real, range_:{0,1}] :=
	Module[ {lower, diagonal},
	lower = Table[ RandomComplexVector[j - 1, type, range] ~Join~
		Table[0, {n - (j - 1)}], {j, 1, n}];
	diagonal = DiagonalMatrix[RandomVector[n, type, range]];
	lower + ConjugateTranspose[lower] + diagonal
]



RandomSkewHermitianMatrix[n_Integer?Positive, type_:Real, range_:{0,1}] :=
	Module[ {lower,diagonal},
	lower = Table[ RandomComplexVector[j - 1, type, range] ~Join~
		Table[0, {n - (j - 1)}], {j, 1, n}];
	diagonal = DiagonalMatrix[I RandomVector[n, type, range]];
	lower - ConjugateTranspose[lower] + diagonal
]



TriangularMatrix[a_, n_Integer, k_Integer: 0, opts___?OptionQ] :=
	Module[{subscript}, 
	subscript = Subscript /. {opts} /. Options[TriangularMatrix]; 
	SparseArray[{{m_, j_} /; (m +k  <= j) :> If[subscript, Subscript[a, m, j], a[m, j]]}, {n, n}] // Normal]

SymmetricArray[anything___] := Print["SymmetricArray has been renamed SymmetricMatrix."];

SymmetricMatrix[a_,n_,opts___] := 
	TriangularMatrix[a,n,opts] + Transpose[TriangularMatrix[a,n,1,opts]]
	
RandomTriangularMatrix[n_Integer?Positive, type_:Real, range_:{0,1}] := 
	Table[ Table[0,{j - 1}] ~ Join ~ 
		RandomVector[n - (j - 1), type, range], {j,1,n}]
		
RandomOrthogonalMatrix[n_, type_:Real, range_:{0,1}] := 
	Block[{mat = RandomMatrix[n,type,range]},
	While[MatrixRank[mat] < n,mat = RandomMatrix[n,type,range]];
	Orthogonalize[mat]
]

RandomUnitaryMatrix[n_, type_:Real, range_:{0,1}] := 
	Block[{mat = RandomComplexMatrix[n,type,range]},
	While[MatrixRank[mat] < n,mat = RandomComplexMatrix[n,type,range]];
	Orthogonalize[mat]
]


RandomInvolution[n_, type_Symbol:Real, range_List:{0, 1}, opts___Rule] := 
   Module[{k = Random[Integer, {1, n - 1}], matA, matB},
	matA = RandomMatrix[{n-k, k}, type, range];
	matB = RandomMatrix[{k, n-k}, type, range];
	Join[MapThread[Flatten[{#1,#2}]&,
		{IdentityMatrix[k] - matB.matA, matB}],
    	     MapThread[ Flatten[{#1,#2}]&,
		{2matA - matA.matB.matA, matA.matB - IdentityMatrix[n-k]}]]]
		
		
RandomPermutationMatrix[size_?IntegerQ] :=
	Part[IdentityMatrix[size],
		Map[Last,Sort[Table[{Random[],i},{i,size}]]]]


VandermondeMatrix[data_List, n_] := 
  With[{m = Length[data]}, Transpose[NestList[data*#1 & , Table[1, {m}], n-1]]]



LagrangeBasis::variable = "The data cannot contain the variable name.";
LagrangeBasis[(data_)?VectorQ, x_] := 
	If[FreeQ[data,x,Infinity],
		Table[Times @@ (x - Drop[data, {i}])/
    			Times @@ (data[[i]] - Drop[data, {i}]), {i, 1, Length[data]}],
    		Return[Message[LagrangeBasis::variable]]]
	

End[];

SetAttributes[{AugmentedMatrix}, {(*HoldFirst,*) ReadProtected, Protected, Locked}];

SetAttributes[
	{BasisIntersection, BasisSum, LeftNullSpace, NewLU, LDU, RandomInvolution, SubspaceQ, FindMatrix, ChangeBasis, Coordinates, 
	StandardBasisMatrices, SBMatrices, StandardBasisSMatrices, SBSMatrices, StandardBasisSSMatrices, SBSSMatrices, StandardBasisTraceZeroMatrices, SBTZMatrices,  
	StandardBasisDiagonalMatrices, SBDMatrices,
	StandardBasisPolys, SBPolys, StandardBasisTrigPolys, SBTPolys,  LagrangeBasis, VandermondeMatrix, MakeLC, 

	ReduceEquations, ReduceMatrix, ScaleEquation, ScaleRow, ElementaryMatrix1, ElementaryMatrix2, ElementaryMatrix3, 
	SameSpanQ, NewQRDecomposition,
	RandomMatrix, RandomOrthogonalMatrix, RandomPermutationMatrix, RandomSymmetricMatrix, RandomSkewSymmetricMatrix, 
	RandomTriangularMatrix, RandomVector, RandomUnitaryMatrix, RandomComplexVector, RandomHermitianMatrix, RandomSkewHermitianMatrix, 

	TriangularMatrix, SymmetricMatrix,  PermutationMatrix, 
	JordanNilpotent, JordanBlock, JordanMatrix, 

	ZeroMatrix, ZeroVector, 

	MatrixPowers, 

	TriangularMatrixQ, 

	NewGeometricTransformation,

	CoefficientMatrix, coefficientmatrix, (*AugmentedMatrix,*) ConstraintEqns,

	InterchangeRows, InterchangeColumns, AppendColumn, AppendRow, PrependRow, PrependColumn, DropColumn, DropRow, TakeColumn, TakeRow,



	Rank, SymbolicRowReduce, ColumnSpace, PivotColumns, RowSpace, 

	CompleteSquare, DiagQuad, NDiagQuad, 

	GramSchmidt, ProjectionMatrix, ProjectVector,


	CoefficientRange}, 
	
	{(*ReadProtected,*) Protected, Locked}];

EndPackage[];
